% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}
В данном разделе представлены некоторые технические подробности проделанной работы и ограничения, которые мешают проводить дальнейшую разработку без существенных изменений. Исходный код доступен по ссылке \url{https://github.com/KubEF/matrix-lib}
\subsection{Деревья квадрантов}
Для начала необходимо было реализовать базовую функциональность для работы с матрицами, представленными в виде деревьев квадрантов. Это рекурсивная структура данных, для задания таковых в языке \Haskell{} существует крайне удобное представление: алгебраические типы данных. Оно позволяет кратко записывать типы, которые будут являться одним из представителей.
\begin{lstlisting}[caption={пример конструирования односвязного списка над целыми числами}, language=Haskell, frame=single]
    data MyList Int = Nil | Cons Int (MyList Int)
\end{lstlisting}
Тип дерева квадрантов представлено в коде похожим образом
\begin{lstlisting}[caption={задание типа дерева квадрантов в библоитеке}, language=Haskell, frame=single, basicstyle=\ttfamily]
data QuadTree a =
    Leaf a Int
    | Node (QuadTree a) (QuadTree a) (QuadTree a) (QuadTree a)
\end{lstlisting}
В следствие такой структуры, реализовать поэлементные операции довольно просто~--- необходимо синхронно обходить деревья и применять операцию, когда дошли до листьев (если встретился узел и лист, то делим размер листа на два и так же спускаемся ниже). Умножение же на такой структуре данных работает схожим образом с обычными матрицами~\cite{10.1007/3-540-51084-2_9}:
\begin{gather*}
    \begin{bmatrix}
        NW_1 & NE_1 \\
        SW_1 & SE_1
    \end{bmatrix}
    \times
    \begin{bmatrix}
        NW_2 & NE_2 \\
        SW_2 & SE_2
    \end{bmatrix} = \\ =
    \begin{bmatrix}
        NW_1 \times NW_2 + NE_1 \times SW_2 & NW_1 \times NW_2 + NE_1 \times SW_2  \\
        SW_1 \times NW_2 + SE_1 \times SW_2 & SW_1 \times NE_2 + SE_1 \times SE_2
    \end{bmatrix}
\end{gather*}
Так что реализация умножения представляет собой синхронный обхода дерева с раздваиванием на каждом шаге.
\subsection{Генерация оптимизированного кода}
Чтобы избежать промежуточных структур данных, которые возникают при последовательном применении нескольких поэлементных операций, при помощи \Th{} генерируется код, который будет так же синхронно обходить не два, а, в общем случае, $n$ деревьев. Этот подход позволит сразу создавать ответ без аллокаций промежуточных результатов. \Th{} здесь необходим, так как он позволяет генерировать код по шаблону, а количество случаев, которые нужно обработать, растёт экспоненциально от $n$.

Однако если попытаться оптимизировать связку умножения матриц и потом применения поэлементной операции, то возникнут проблемы: в общем случае этот подход просто не работает. Основная идея в том, чтобы мочь делать рекурсивный синхронный шаг в разборе всех деревьев, поданных на вход. При отсутствии дистрибутивности поэлементной операции относительно \enquote{сложения}, которое определяет пользователь, будет необходимо посчитать промежуточную матрицу.
\subsection{Вывод}
В общем случае техника \enquote{слияние ядер} в связке с \Th{} имеет необходимые ограничения, которые не позволяют соптимизировать умножение $n$ матриц и даже умножение двух матриц с последующим применением поэлементной операции
