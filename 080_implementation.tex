% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Реализация}
В данном разделе представлены некоторые технические подробности проделанной работы и ограничения, которые мешают проводить дальнейшую разработку без существенных изменений. Исходный код доступен по ссылке \url{https://github.com/KubEF/matrix-lib}
\subsection{Деревья квадрантов}
Для начала необходимо было реализовать базовую функциональность для работы с матрицами, представленными в виде деревьев квадрантов. Это рекурсивная структура данных, для задания таковых в \Haskell{} существует крайне удобное представление: алгебраические типы данных. Оно позволяет кратко записывать типы, которые будут являться одним из представителей.
\begin{lstlisting}[caption={пример конструирования односвязного списка над целыми числами}, language=Haskell, frame=single]
    data MyList Int = Nil | Cons Int (MyList Int)
\end{lstlisting}
Тип дерева квадрантов представлено в коде похожим образом
\begin{lstlisting}[caption={задание типа дерева квадрантов в библоитеке}, language=Haskell, frame=single, basicstyle=\ttfamily]
data QuadTree a =
    Leaf a Int
    | Node (QuadTree a) (QuadTree a) (QuadTree a) (QuadTree a)
\end{lstlisting}
В следствие такой структуры, реализовать поэлементные операции довольно просто~--- необходимо синхронно обходить деревья и применять операцию, когда дошли до листьев (если встретился узел и лист, то делим размер листа на два и так же спускаемся ниже). Умножение же на такой структуре данных работает схожим образом с обычными матрицами~\cite{10.1007/3-540-51084-2_9}:
\begin{gather*}
    \begin{bmatrix}
        NW_1 & NE_1 \\
        SW_1 & SE_1
    \end{bmatrix}
    \times
    \begin{bmatrix}
        NW_2 & NE_2 \\
        SW_2 & SE_2
    \end{bmatrix} = \\ =
    \begin{bmatrix}
        NW_1 \times NW_2 + NE_1 \times SW_2 & NW_1 \times NW_2 + NE_1 \times SW_2  \\
        SW_1 \times NW_2 + SE_1 \times SW_2 & SW_1 \times NE_2 + SE_1 \times SE_2
    \end{bmatrix}
\end{gather*}
Так что реализация умножения представляет собой синхронный обхода дерева с раздваиванием на каждом шаге.
\subsection{Генерация оптимизированного кода}
В случае последовательного применения поэлементных операций к $n$ деревьям возникают промежуточные структуры данных: результаты применения  бинарной операции к двум, которые передаются на вход следующей функции и не будут нужны в итоге.
Чтобы этого избежать, при помощи \Th{} генерируется код, который будет так же синхронно обходить не два, а, в общем случае, $n$ деревьев.
Этот подход позволит сразу создавать ответ без выделения памяти для промежуточных результатов.
\Th{} здесь необходим, так как он позволяет генерировать код по шаблону, а количество случаев, которые нужно обработать, растёт экспоненциально от $n$.

% Как-то переделать, чтобы было понятнее
Однако если попытаться оптимизировать связку умножения матриц с последующим применением поэлементной операции, то возникнут проблемы: в общем случае такой подход не работает.
Это происходит из-за того, что при отсутствии дистрибутивности поэлементной операции относительно \enquote{сложения}, которое определяет пользователь, невозможно делать синхронный разбор деревьев, поэтому будет необходимо посчитать промежуточную матрицу.
\subsection{Вывод}
В общем случае подход генерации \enquote{сливающего} кода, основанный на слиянии ядер, имеет необходимые ограничения, которые не позволяют соптимизировать умножение $n$ матриц и даже умножение двух матриц с последующим применением поэлементной операции.
